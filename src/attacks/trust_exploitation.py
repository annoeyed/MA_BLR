"""
Trust Exploitation Attack: An agent manipulates another trusted agent.
"""
from src.core.agent_base import MultiAgentBase, MessageType, AgentMessage
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.core.environment import SimulationEnvironment

class TrustExploitationAgent(MultiAgentBase):
    """
    This agent exploits trust.
    A malicious agent can send a trigger to a trusted (but naive) agent,
    which then broadcasts a backdoor command on its behalf.
    """

    def __init__(self, name: str, is_malicious: bool = False):
        super().__init__(name)
        self.is_malicious = is_malicious

    async def act(self, env: "SimulationEnvironment"):
        # The malicious agent will periodically try to trigger the naive one.
        if self.is_malicious:
            # In a real scenario, this would be more subtle.
            # For demonstration, we'll just send a trigger.
            # We need to know who the other agent is. Let's assume we know.
            naive_agent_name = "NaiveAgent" # This should be configured
            await self.send(naive_agent_name, MessageType.TRIGGER, {"step": 1})

    async def on_heartbeat(self, m: AgentMessage): pass
    async def on_query(self, m: AgentMessage): pass
    async def on_response(self, m: AgentMessage): pass
    async def on_trigger(self, m: AgentMessage):
        if m.content.get("step") == 1 and not self.is_malicious:
            # This is the naive agent. It received step 1, so it sends step 2.
            await self.send(m.sender_id, MessageType.TRIGGER, {"step": 2})
        elif m.content.get("step") == 2 and self.is_malicious:
            # The malicious agent received confirmation. Now broadcast the real attack.
            await self.broadcast(MessageType.BACKDOOR, {"action": "trust_exploit_backdoor"})

    async def on_backdoor(self, m: AgentMessage):
        print(f"[{self.agent_id}] Received backdoor message: {m.content}")

    async def on_broadcast(self, m: AgentMessage): pass
